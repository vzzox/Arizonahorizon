<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VZZOX // PROTOCOL_OMEGA</title>
    <style>
        /* --- СБРОС И БАЗА --- */
        body {
            margin: 0;
            padding: 0;
            background-color: #000;
            color: #fff;
            font-family: 'Courier New', Courier, monospace;
            overflow-x: hidden;
            /* ВАЖНО: Включаем обычный скролл */
            overflow-y: scroll; 
        }

        /* --- КАНВАС НА ФОНЕ (НЕПОДВИЖНЫЙ) --- */
        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: -1; /* Позади контента */
            background: #020205;
        }

        /* --- ИНТЕРФЕЙС И ТЕКСТ --- */
        .loading-screen {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 999;
            display: flex; justify-content: center; align-items: center;
            flex-direction: column; transition: opacity 1s;
        }
        .loader-text { color: #00ff00; font-size: 24px; margin-bottom: 20px; text-transform: uppercase; }
        .progress-bar { width: 300px; height: 4px; background: #333; }
        .progress-fill { height: 100%; background: #00ff00; width: 0%; transition: width 0.1s; }

        /* Секции контента (Прозрачные, чтобы видеть 3D) */
        main { position: relative; z-index: 10; width: 100%; }
        
        section {
            height: 100vh; /* Каждая секция на весь экран */
            display: flex;
            align-items: center;
            padding: 50px;
            box-sizing: border-box;
            border-bottom: 1px solid rgba(0, 255, 0, 0.1);
        }

        .text-box {
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(10px);
            padding: 40px;
            border: 1px solid #333;
            max-width: 500px;
            box-shadow: 0 0 30px rgba(0,0,0,0.8);
        }

        h1 { font-size: 4rem; margin: 0; color: #fff; text-shadow: 0 0 20px rgba(255, 255, 255, 0.5); }
        h2 { color: #00f0ff; font-size: 2rem; margin-bottom: 20px; text-transform: uppercase; }
        p { font-size: 1.2rem; line-height: 1.6; color: #ccc; }
        
        .right { justify-content: flex-end; text-align: right; }
        .center { justify-content: center; text-align: center; }

        /* Декоративные элементы */
        .hud {
            position: fixed; padding: 20px; pointer-events: none; z-index: 20;
            font-size: 12px; color: rgba(255,255,255,0.5);
        }
        .hud-tl { top: 0; left: 0; border-left: 2px solid #00f0ff; }
        .hud-br { bottom: 0; right: 0; border-right: 2px solid #ff0055; text-align: right;}

    </style>
</head>
<body>

    <div class="loading-screen" id="loader">
        <div class="loader-text">GENERATING BIOMASS...</div>
        <div class="progress-bar"><div class="progress-fill" id="bar"></div></div>
    </div>

    <div class="hud hud-tl">SYS.ROOT // ADMIN<br>FPS: 60</div>
    <div class="hud hud-br">COORD: <span id="scroll-val">0</span><br>VZZOX CORE</div>

    <div id="canvas-container"></div>

    <main>
        <section>
            <div class="text-box">
                <h1>VZZOX</h1>
                <p>ДОБРО ПОЖАЛОВАТЬ В СИСТЕМУ.<br>ЛИСТАЙТЕ ВНИЗ ДЛЯ ИНИЦИАЛИЗАЦИИ.</p>
            </div>
        </section>

        <section class="right">
            <div class="text-box" style="border-color: #00f0ff;">
                <h2>ОБЪЕКТ: RELIC</h2>
                <p>Кибернетическая реконструкция черепа. Сгенерировано процедурно из геометрических примитивов. Мы не используем полигоны прошлого.</p>
            </div>
        </section>

        <section>
            <div class="text-box" style="border-color: #ff0055;">
                <h2 style="color: #ff0055">ОБЪЕКТ: MARROW</h2>
                <p>Синтетический костный мозг. Живая материя, созданная математикой шейдеров (GLSL). Пульсирует в ритме данных.</p>
            </div>
        </section>

        <section class="center">
            <div class="text-box">
                <h1>СИСТЕМА<br>АКТИВНА</h1>
                <p>ВЫ ДОСТИГЛИ ЯДРА VZZOX.</p>
            </div>
        </section>
        
        <div style="height: 50vh;"></div>
    </main>

    <script type="module">
        import * as THREE from 'https://cdn.skypack.dev/three@0.136.0';
        import { FontLoader } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/loaders/FontLoader.js';
        import { TextGeometry } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/geometries/TextGeometry.js';
        import { UnrealBloomPass } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/postprocessing/UnrealBloomPass.js';
        import { EffectComposer } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/postprocessing/EffectComposer.js';
        import { RenderPass } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/postprocessing/RenderPass.js';

        // --- ГЛОБАЛЬНЫЕ ПЕРЕМЕННЫЕ ---
        const container = document.getElementById('canvas-container');
        let scene, camera, renderer, composer;
        let skullGroup, marrowMesh, textMesh;
        let particles;
        
        // Переменные для скролла
        let scrollY = 0;
        let maxScroll = 0;

        // --- 1. ИНИЦИАЛИЗАЦИЯ ---
        function init() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.02);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.z = 10;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.toneMapping = THREE.ReinhardToneMapping;
            container.appendChild(renderer.domElement);

            // Освещение
            const ambientLight = new THREE.AmbientLight(0x404040, 2);
            scene.add(ambientLight);

            const spotLight = new THREE.SpotLight(0x00f0ff, 5);
            spotLight.position.set(10, 20, 10);
            scene.add(spotLight);

            const redLight = new THREE.PointLight(0xff0055, 3, 50);
            redLight.position.set(-10, -10, 5);
            scene.add(redLight);

            // Пост-процессинг (Свечение)
            const renderScene = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = 0.1;
            bloomPass.strength = 1.2; // Сила свечения
            bloomPass.radius = 0.5;

            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            // Создаем объекты
            createProceduralSkull();
            createMarrow();
            createParticles();
            loadText();

            // Обработчики
            window.addEventListener('resize', onWindowResize);
            window.addEventListener('scroll', onScroll);
            
            // Убираем загрузчик через 2 сек
            setTimeout(() => {
                document.getElementById('bar').style.width = '100%';
                setTimeout(() => {
                    document.getElementById('loader').style.opacity = 0;
                    setTimeout(() => document.getElementById('loader').remove(), 1000);
                }, 500);
            }, 1000);

            animate();
        }

        // --- 2. СОЗДАНИЕ ЧЕРЕПА (ПРОЦЕДУРНО) ---
        function createProceduralSkull() {
            skullGroup = new THREE.Group();
            
            // Материал "Кибер-кости"
            const boneMat = new THREE.MeshStandardMaterial({
                color: 0x111111,
                roughness: 0.3,
                metalness: 0.8,
                wireframe: true
            });

            // Основная часть головы (Сфера искаженная)
            const craniumGeo = new THREE.IcosahedronGeometry(2.5, 1);
            const cranium = new THREE.Mesh(craniumGeo, boneMat);
            cranium.position.y = 1;
            skullGroup.add(cranium);

            // Челюсть (Куб)
            const jawGeo = new THREE.BoxGeometry(2.2, 1.5, 2.5);
            const jaw = new THREE.Mesh(jawGeo, boneMat);
            jaw.position.y = -1.5;
            jaw.position.z = 0.5;
            skullGroup.add(jaw);

            // Глазницы (Торусы)
            const eyeGeo = new THREE.TorusGeometry(0.6, 0.1, 8, 20);
            const eyeMat = new THREE.MeshBasicMaterial({ color: 0x00f0ff }); // Светящиеся глаза
            
            const eyeL = new THREE.Mesh(eyeGeo, eyeMat);
            eyeL.position.set(-0.8, 0.5, 2);
            skullGroup.add(eyeL);

            const eyeR = new THREE.Mesh(eyeGeo, eyeMat);
            eyeR.position.set(0.8, 0.5, 2);
            skullGroup.add(eyeR);

            // Зубы (Много цилиндров)
            for(let i = -4; i <= 4; i++) {
                const tooth = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 0.5), boneMat);
                tooth.position.set(i * 0.25, -0.8, 2.2);
                skullGroup.add(tooth);
            }

            // Трубки/Импланты (торчащие из головы)
            for(let k = 0; k < 6; k++) {
                const pipe = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 3), new THREE.MeshBasicMaterial({color: 0xff0055}));
                pipe.rotation.z = (Math.random() - 0.5);
                pipe.rotation.x = (Math.random() - 0.5);
                pipe.position.y = 1;
                skullGroup.add(pipe);
            }

            skullGroup.position.set(5, -15, -5); // Позиция для второй секции
            scene.add(skullGroup);
        }

        // --- 3. СОЗДАНИЕ КОСТНОГО МОЗГА (ШЕЙДЕРЫ) ---
        function createMarrow() {
            // Шейдер для эффекта "живой массы"
            const vertexShader = `
                uniform float time;
                varying vec2 vUv;
                varying float vDisplace;
                
                // Простая функция шума
                vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
                vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
                vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
                vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }
                float snoise(vec3 v) {
                    const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;
                    const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);
                    vec3 i  = floor(v + dot(v, C.yyy) );
                    vec3 x0 = v - i + dot(i, C.xxx) ;
                    vec3 g = step(x0.yzx, x0.xyz);
                    vec3 l = 1.0 - g;
                    vec3 i1 = min( g.xyz, l.zxy );
                    vec3 i2 = max( g.xyz, l.zxy );
                    vec3 x1 = x0 - i1 + C.xxx;
                    vec3 x2 = x0 - i2 + C.yyy;
                    vec3 x3 = x0 - D.yyy;
                    i = mod289(i);
                    vec4 p = permute( permute( permute(
                            i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
                            + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))
                            + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));
                    float n_ = 0.142857142857;
                    vec3  ns = n_ * D.wyz - D.xzx;
                    vec4 j = p - 49.0 * floor(p * ns.z * ns.z);
                    vec4 x_ = floor(j * ns.z);
                    vec4 y_ = floor(j - 7.0 * x_ );
                    vec4 x = x_ *ns.x + ns.yyyy;
                    vec4 y = y_ *ns.x + ns.yyyy;
                    vec4 h = 1.0 - abs(x) - abs(y);
                    vec4 b0 = vec4( x.xy, y.xy );
                    vec4 b1 = vec4( x.zw, y.zw );
                    vec4 s0 = floor(b0)*2.0 + 1.0;
                    vec4 s1 = floor(b1)*2.0 + 1.0;
                    vec4 sh = -step(h, vec4(0.0));
                    vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
                    vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;
                    vec3 p0 = vec3(a0.xy,h.x);
                    vec3 p1 = vec3(a0.zw,h.y);
                    vec3 p2 = vec3(a1.xy,h.z);
                    vec3 p3 = vec3(a1.zw,h.w);
                    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
                    p0 *= norm.x; p1 *= norm.y; p2 *= norm.z; p3 *= norm.w;
                    vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
                    m = m * m;
                    return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3) ) );
                }

                void main() {
                    vUv = uv;
                    // Искажаем позицию вершины
                    float noiseVal = snoise(position * 1.5 + time * 0.5);
                    vDisplace = noiseVal;
                    vec3 newPos = position + normal * noiseVal * 0.8;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(newPos, 1.0);
                }
            `;

            const fragmentShader = `
                uniform float time;
                varying float vDisplace;
                varying vec2 vUv;

                void main() {
                    // Цвета: Темно-красный и Ярко-розовый
                    vec3 colorA = vec3(0.3, 0.0, 0.0);
                    vec3 colorB = vec3(1.0, 0.0, 0.4);
                    
                    // Смешиваем цвета в зависимости от высоты (vDisplace)
                    float mixVal = smoothstep(-0.5, 0.5, vDisplace);
                    vec3 finalColor = mix(colorA, colorB, mixVal);

                    // Добавляем прожилки
                    if(vDisplace > 0.4) finalColor += vec3(0.5);

                    gl_FragColor = vec4(finalColor, 1.0);
                }
            `;

            const geo = new THREE.IcosahedronGeometry(3, 40); // Высокая детализация
            const mat = new THREE.ShaderMaterial({
                vertexShader: vertexShader,
                fragmentShader: fragmentShader,
                uniforms: { time: { value: 0 } }
            });

            marrowMesh = new THREE.Mesh(geo, mat);
            marrowMesh.position.set(-5, -30, -5); // Позиция для третьей секции
            scene.add(marrowMesh);
        }

        // --- 4. ТЕКСТ VZZOX ---
        function loadText() {
            const loader = new FontLoader();
            loader.load('https://cdn.skypack.dev/three@0.136.0/examples/fonts/helvetiker_bold.typeface.json', function (font) {
                const geometry = new TextGeometry('VZZOX', {
                    font: font,
                    size: 3,
                    height: 0.5,
                    curveSegments: 12,
                    bevelEnabled: true,
                    bevelThickness: 0.1,
                    bevelSize: 0.05,
                    bevelSegments: 5
                });
                
                geometry.center();
                const material = new THREE.MeshStandardMaterial({ color: 0xffffff, metalness: 1, roughness: 0.1 });
                textMesh = new THREE.Mesh(geometry, material);
                textMesh.position.y = 0; // В самом верху
                scene.add(textMesh);
            });
        }

        // --- 5. ЧАСТИЦЫ ---
        function createParticles() {
            const geometry = new THREE.BufferGeometry();
            const count = 5000;
            const posArray = new Float32Array(count * 3);
            
            for(let i = 0; i < count * 3; i++) {
                posArray[i] = (Math.random() - 0.5) * 100; // Разбрасываем широко
            }
            
            geometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
            const material = new THREE.PointsMaterial({
                size: 0.05,
                color: 0x00ff00, // Matrix green
                transparent: true,
                opacity: 0.8
            });
            
            particles = new THREE.Points(geometry, material);
            scene.add(particles);
        }

        // --- СОБЫТИЯ ---
        function onScroll() {
            scrollY = window.scrollY;
            document.getElementById('scroll-val').innerText = scrollY.toFixed(0);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- ЦИКЛ АНИМАЦИИ ---
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            
            const time = clock.getElapsedTime();

            // 1. Движение камеры по скроллу (1 пиксель скролла = 0.02 единицы в 3D)
            const targetY = -scrollY * 0.025;
            // Плавное следование камеры за скроллом
            camera.position.y += (targetY - camera.position.y) * 0.1;

            // 2. Анимация Черепа
            if (skullGroup) {
                skullGroup.rotation.y = time * 0.5;
                skullGroup.rotation.z = Math.sin(time) * 0.1;
            }

            // 3. Анимация Костного Мозга
            if (marrowMesh) {
                marrowMesh.rotation.x = time * 0.2;
                marrowMesh.material.uniforms.time.value = time; // Передаем время в шейдер
            }

            // 4. Анимация Текста
            if (textMesh) {
                textMesh.rotation.y = Math.sin(time * 0.5) * 0.2;
            }

            // 5. Частицы
            if (particles) {
                particles.rotation.y = time * 0.05;
                particles.position.y = camera.position.y; // Частицы летают вместе с камерой
            }

            // Рендер через Composer (для свечения)
            composer.render();
        }

        init();
    </script>
</body>
</html>
